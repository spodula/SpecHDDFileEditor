package hddEditor.libs.partitions.cpm;

import hddEditor.libs.Speccy;

/*-*
 * This is a wrapper around a spectrum +3 dos file, its header and file types.
 * 
 * Every valid file +3 dos file has a header of these in the first 128 bytes of
 * the CPM file. It provides information such at the proper byte-level file size
 * (CPM has file sizes in 128 bytes) The filesize in the header includes the
 * header in its size.
 * 
 * In addition BASIC has its own header so it can tell what type of file of it.
 * It also has a file size. This DOES NOT include the header. Its the size of
 * the file as basic sees it. As such FileLength in the +3 basic header is
 * always 128 bytes lower than the one in the PLUS3DOS header.
 * 
 * Format of the header is:
 * +------+-------------------------------------------------------------------------------+
 * |00-07 | "PLUS3DOS"                                                                    |
 * |08    | Soft EOF character provided when reading and the file runs out. (1A on the +3)| 
 * |09    | Issue number (1)                                                              |
 * |0A    | Version number (0)                                                            |
 * |0B-0E | Filesize including the header length - LSB first                              |
 * |0F-16 | BASIC header (See below)                                                      |
 * |17-7E | Reserved (0)                                                                  |
 * |7F    | Checksum byte                                                                 |
 * +------+-------------------------------------------------------------------------------+
 * 
 * Checksum is simply the modulus of the bytes from 0-126 Easily generated by
 * z80 by just adding all the bytes together and ignoring any carry's
 * 
 * 
 * BASIC header (bytes 15-22) This is similar to the tape header minus the
 * filename. See
 * https://sinclair.wiki.zxnet.co.uk/wiki/Spectrum_tape_interface#Header_block
 * for that information. 
 * +-----+--------------------------------------+
 * | 0 	 | File type (0-3)                      |
 * | 1-2 | File length as seen by +3 BASIC      |
 * | 3-4 | Var 1 - Contents depend on file type |
 * | 5-6 | Var 2 - Contents depend on file type |
 * +-----+--------------------------------------+
 * 
 * BASIC file types are as follows:
 * +---+-----------------+-----------------------+-----------------------------+
 * |typ| Filetype        | Var 1                 | Var 2                       |
 * +---+-----------------+-----------------------+-----------------------------+
 * | 0 | BASIC           | Autostart line        | Start of the variables area |
 * | 1 | Numeric Array   | MSB used for var name | unused                      |
 * | 2 | Character array | MSB used for var name | unused                      |
 * | 3 | CODE            | Load address          | unused                      |
 * +---+-----------------+-----------------------+-----------------------------+
 * For arrays, the second byte of VAR 1 (hdr+4) contains an encoded version
 * of the variable name. This is informational only as when loaded in BASIC, you have to
 * specify a target variable. It also flags whether its a character or numeric array.
 * Again, this information is of no actual use because this is defined by the file type field 
 *
 * Array name is encoded as follows: byte[4]:
 * 		The array name (Always 1 char) is encoded as:
 * 		follows: 1Y0XXXXX where Y=1 for String array, 0 for numeric. and XXXXX is the uppercase character - 0x60
 *
 *	so A$() would be (type=2), 11000001, b() (type=3) 10000010
 *
 * Sources:
 * https://retrocomputing.stackexchange.com/questions/14486/what-file-formats-were-used-for-binary-executable-files-on-later-sinclair-zx-spe
 * https://worldofspectrum.org/ZXSpectrum128+3Manual/chapter8pt27.html
 * 
 * @author Graham
 * 
 * 22 mar 2025 GDS - Changed so all dynamically accessed from the raw data. 
 * 					 This will make modifying and saving the data easier.
 *
 */

public class Plus3DosFileHeader {
	public static int Plus3HEADER_SIZE = 0x80;
	// +3 DOS HEADER data
	public byte RawHeader[] = new byte[Plus3HEADER_SIZE];

	// basic types
	public static int FILETYPE_BASIC = 0;
	public static int FILETYPE_NUMARRAY = 1;
	public static int FILETYPE_CHRARRAY = 2;
	public static int FILETYPE_CODE = 3;

	public String GetVarName() {
		if (IsPlus3DosFile()) {
			byte hdr[] = GetPlus3BasicHeader();
			if ((GetFileType() == FILETYPE_NUMARRAY) || (GetFileType() == FILETYPE_CHRARRAY)) {
				int c = (hdr[4] & 0x1f) + 0x60;
				String VarName = String.valueOf((char) c);
				if (GetFileType() == FILETYPE_CHRARRAY) {
					VarName = VarName + "$";
				}
				return (VarName.toUpperCase());
			} else {
				return ("");
			}
		} else {
			return ("");
		}

	}

	/**
	 * Set variable name for data array file types.
	 * 
	 * @param varName
	 */
	public void SetVarName(String varName) {
		char c = (varName.toUpperCase() + "A").charAt(0);
		int b = (byte) c;
		b = b - 0x60;
		b = b & 0x1f;
		byte hdr[] = GetPlus3BasicHeader();
		hdr[4] = (byte) ((b + 0x80) & 0xff);
		SetPlus3BasicHeader(hdr);
	}

	/**
	 * Line number...
	 * 
	 * @return
	 */
	public int GetLine() {
		return (GetVar1());
	}

	public void SetLine(int line) {
		SetVar1(line);
	}

	/**
	 * Load address...
	 * 
	 * @return
	 */
	public int GetLoadAddress() {
		return (GetVar1());
	}

	public void SetLoadAddress(int LoadAddr) {
		SetVar1(LoadAddr);
	}

	/**
	 * Get the V1 parameters
	 * 
	 * @return
	 */
	public int GetVar1() {
		if (IsPlus3DosFile()) {
			byte hdr[] = GetPlus3BasicHeader();
			int var1 = ((int) hdr[4] & 0xff) * 0x100 + ((int) hdr[3] & 0xff);
			return (var1);
		} else {
			return (0);
		}
	}

	/**
	 * Set the V1 parameter
	 * 
	 * @param line
	 */
	public void SetVar1(int var1) {
		if (IsPlus3DosFile()) {
			int lsb = var1 & 0xff;
			int msb = (var1 & 0xff00) >> 8;
			byte hdr[] = GetPlus3BasicHeader();
			hdr[4] = (byte) (msb & 0xff);
			hdr[3] = (byte) (lsb & 0xff);
			SetPlus3BasicHeader(hdr);
		}
	}

	/**
	 * Variables offset
	 * 
	 * @return
	 */
	public int GetVarsOffset() {
		return (GetVar2());
	}

	public void SetVarsOffset(int varsOffset) {
		SetVar2(varsOffset);
	}

	/**
	 * Get the V2 parameter
	 * 
	 * @return
	 */
	public int GetVar2() {
		if (IsPlus3DosFile()) {
			byte hdr[] = GetPlus3BasicHeader();
			int var2 = ((int) hdr[6] & 0xff) * 0x100 + ((int) hdr[5] & 0xff);
			return (var2);
		} else {
			return (0);
		}
	}

	/**
	 * Set the V2 parameter
	 * 
	 * @param line
	 */
	public void SetVar2(int var2) {
		if (IsPlus3DosFile()) {
			int lsb = var2 & 0xff;
			int msb = (var2 & 0xff00) >> 8;
			byte hdr[] = GetPlus3BasicHeader();
			hdr[6] = (byte) (msb & 0xff);
			hdr[5] = (byte) (lsb & 0xff);
			SetPlus3BasicHeader(hdr);
		}
	}

	/**
	 * Get the 8 byte file signature. (Should be PLUS3DOS)
	 * 
	 * @return
	 */
	public String GetSignature() {
		String Signature = "";
		for (int i = 0; i < 8; i++) {
			if ((RawHeader[i] > 31) && (RawHeader[i] < 127))
				Signature = Signature + (char) RawHeader[i];
		}
		return (Signature);
	}

	/**
	 * Set the 8 byte file signature. (Probably shouldnt do this, but here for
	 * completeness)
	 */
	public void SetSignature(String newsig) {
		// Make sure its long enough
		newsig = newsig + "        ";
		for (int i = 0; i < 8; i++) {
			RawHeader[i] = (byte) newsig.charAt(i);
		}
		// Recalculate the checksum
		RecalculateChecksum();
	}

	/**
	 * Get the +3DOS issue number of the file
	 * 
	 * @return
	 */
	public int GetIssueNo() {
		return ((int) (RawHeader[9] & 0xff));
	}

	/**
	 * Set the +3DOS issue number of the file
	 * 
	 * @param NewIssueNo
	 */
	public void SetIssueNo(int NewIssueNo) {
		RawHeader[9] = (byte) (NewIssueNo & 0xff);
		RecalculateChecksum();
	}

	/**
	 * Get the +3dos Version number of the file
	 * 
	 * @return
	 */
	public int GetVersionNo() {
		return ((int) (RawHeader[10] & 0xff));
	}

	/**
	 * Set the +3DOS version number of the file.
	 * 
	 * @param NewVersionNo
	 */
	public void SetVersionNo(int NewVersionNo) {
		RawHeader[10] = (byte) (NewVersionNo & 0xff);
		RecalculateChecksum();
	}

	/**
	 * Get the SoftEOF byte. Note, for +3DOs this should always be $1A
	 * 
	 * @return
	 */
	public int GetSoftEOF() {
		return ((int) (RawHeader[8] & 0xff));
	}

	/**
	 * Set the SoftEOF byte.
	 */
	public void SetSoftEOF(int NewSoftEOF) {
		RawHeader[8] = (byte) (NewSoftEOF & 0xff);
		RecalculateChecksum();
	}

	/**
	 * Get the file length are reported by BASIC (IE, minus its header)
	 * 
	 * @return
	 */
	public int GetBasicFileLength() {
		int filelength = GetDOSFileSize();
		/**
		 * Get-around for a niggle for basic headers. They can only store a maximum of
		 * 65535 for the file length, so if its more than that, fall back to the +3DOS
		 * header value.
		 * 
		 * Not usually a problem, but can cause issues for large snapshots et al.
		 */
		if (GetDOSFileSize() < 0xffff) {
			byte hdr[] = GetPlus3BasicHeader();
			filelength = ((int) hdr[2] & 0xff) * 0x100 + ((int) hdr[1] & 0xff);
		}
		return (filelength);
	}

	/**
	 * Set the file length as reported by basic. Note, this will not update the DOS
	 * file length.
	 */
	public void SetBasicFileLength(int newfilelength) {
		int lsb = newfilelength & 0xff;
		int msb = (newfilelength & 0xff00) >> 8;
		byte hdr[] = GetPlus3BasicHeader();
		hdr[2] = (byte) (msb & 0xff);
		hdr[1] = (byte) (lsb & 0xff);
		SetPlus3BasicHeader(hdr);
	}

	/**
	 * Get the CPM DOS filesize. This will differ from the +3 Basic file size due to
	 * the 128 byte header
	 * 
	 * @return
	 */
	public int GetDOSFileSize() {
		// filesize is a 32 bit value stored LSB first
		int fileSize = (int) RawHeader[11] & 0xff;
		fileSize = fileSize + (((int) RawHeader[12] & 0xff) << 8);
		fileSize = fileSize + (((int) RawHeader[13] & 0xff) << 16);
		fileSize = fileSize + (((int) RawHeader[14] & 0xff) << 24);
		return (fileSize);
	}

	/**
	 * Set the DOs file size. Note, this routine will produce some funky results if
	 * your not careful.
	 */
	public void SetDOSFileSize(int NewFileSize) {
		RawHeader[11] = (byte) (NewFileSize & 0x000000ff);
		RawHeader[12] = (byte) (((NewFileSize & 0x0000ff00) >> 8) & 0xff);
		RawHeader[13] = (byte) (((NewFileSize & 0x00ff0000) >> 16) & 0xff);
		RawHeader[14] = (byte) (((NewFileSize & 0xff000000) >> 24) & 0xff);

		RecalculateChecksum();
	}

	/**
	 * Get the Speccy file type from the BASIC area. Will return -1 if invalid file
	 * type or not a +3DOS file
	 * 
	 * @return
	 */
	public int GetFileType() {
		int filetype = -1;
		if (IsPlus3DosFile()) {
			byte plus3BasicHeader[] = GetPlus3BasicHeader();
			filetype = plus3BasicHeader[0];
			if (filetype > 3) {
				filetype = 3;
			}
		}
		return (filetype);
	}

	/**
	 * Create the object and populated from the passed block. This block must be >
	 * 127 bytes
	 * 
	 * @param block
	 */
	public Plus3DosFileHeader(byte[] block) {
		if (block.length < 0x80) {
			RawHeader = null;
		} else {
			System.arraycopy(block, 0, RawHeader, 0, Plus3HEADER_SIZE);
			// populate the basic header ONLY if valid
			if (IsPlus3DosFile()) {
				byte plus3BasicHeader[] = GetPlus3BasicHeader();

				if ((GetFileType() == FILETYPE_NUMARRAY) || (GetFileType() == FILETYPE_CHRARRAY)) {
					int c = (plus3BasicHeader[4] & 0x1f) + 0x60;
					SetVarName(String.valueOf((char) c));
				}
			}
		}
	}

	/**
	 * Get a textual representation of the file type
	 * 
	 * 
	 * @return
	 */
	public String getTypeDesc() {
		return (Speccy.SpecFileTypeToString(GetFileType()));
	}

	/**
	 * Get the Basic header information
	 * 
	 * @return
	 */
	public byte[] GetPlus3BasicHeader() {
		byte result[] = new byte[7];
		System.arraycopy(RawHeader, 15, result, 0, result.length);

		return (result);
	}

	/**
	 * Set the basic header information and re-calculate the checksum
	 */
	public void SetPlus3BasicHeader(byte newheader[]) {
		System.arraycopy(newheader, 0, RawHeader, 15, 7);

		// checksum
		RecalculateChecksum();
	}

	/**
	 * Update the checksum byte with the new checksum.
	 */
	public void RecalculateChecksum() {
		RawHeader[0x7f] = CalculateChecksum();
	}

	/**
	 * Calculate the checksum and return it.
	 * 
	 * @return
	 */
	public byte CalculateChecksum() {
		// calculate the checksum
		int csum = 0;
		for (int i = 0; i < 127; i++) {
			csum = csum + (int) RawHeader[i] & 0xff;
		}
		return ((byte) (csum & 0xff));
	}

	public boolean ChecksumValid() {
		if(RawHeader==null) {
			return false;
		}
		if (RawHeader.length < 128) {
			return false;
		}
		byte csum = CalculateChecksum();

		return ((csum == (byte) (RawHeader[127] & 0xff)));

	}

	public boolean IsPlus3DosFile() {
		return (ChecksumValid() && GetSignature().equals("PLUS3DOS"));
	}

}
